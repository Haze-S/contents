---
date: '2024-03-28'
title: 'Event'
categories: ['Note']
tags: ['JavaScript', 'WIL']
thumbnail: 'https://github.com/Haze-S/blog-contents/assets/87344625/547cddb1-c39f-4136-bd04-0e6a661608d2'
---

![js-event1](https://github.com/Haze-S/blog-contents/assets/87344625/547cddb1-c39f-4136-bd04-0e6a661608d2)

오늘 날의 JavaScript 는 서버, 모바일 등에서 두루 쓰이지만 원래는 웹 페이지에서 복잡한 기능을 구현할 수 있도록 만들어진 프로그래밍 언어이다. 따라서 정적인 웹 사이트를 동적으로 만들기 위해 자바스크립트에는 웹에서 발생되는 상호작용을 핸들링 할 수 있는 내장 객체가 있다.

## 이벤트 객체 (Event Object)

Event 는 DOM에서 발생하는 이벤트를 나타낸다. 이벤트는 사용자의 액션에서 발생하거나 비동기적 작업의 진행을 나타내기 위해 API들이 생성할 수도 있다. 또한 요소의 `click()` 등의 메서드를 호출하거나 이벤트를 정의한 후 대상의 `dispatchEvent()` 를 사용해 발송하는 등 프로그래밍으로 만들 수도 있다.

이벤트의 종류는 다양하며 이벤트가 발생하면 핸들러의 첫 번째 파라미터에는 자동으로 이벤트 객체가 전달된다. 이벤트 객체는 가지고 있는 프로퍼티가 종류마다 다르며, 이벤트에 대한 정보들을 프로퍼티로 가지고 있다.

### **이벤트는 전파가 된다.**

이벤트 전파는 계층 구조로 이루어진 DOM에서는 당연히 일어나는 현상일 수도 있다. 또한 이러한 특징 때문에 이벤트 등록 코드를 줄일 수 있다는 장점도 있다.

예로 중첩된 많은 요소가 각자 자신의 이벤트 핸들러를 가지고 있다면 이벤트 처리는 매우 복잡해질 수 있다. 특히 부모와 자식 요소가 화면에 차지하는 영역이 겹쳐 이벤트가 양쪽 모두에서 발생하는 경우, 그 처리 순서는 각 핸들러의 버블링과 캡쳐 설정에 따라 달라진다.

## 버블링

브라우저의 이벤트는 기본적으로 버블링 방식으로 이벤트가 전파된다.

버블링이란 한 요소에서 이벤트가 발생하면, 해당 요소에 할당된 핸들러가 동작하고 이어서 부모의 핸들러도 동작하는 과정이다. 이는 가장 최상단의 조상 요소를 만날 때까지 반복되며 각각의 핸들러가 동작한다. 이처럼 자식 요소에서 시작해서 부모, 조상 요소까지 이벤트가 전파되는 것이 마치 물 속의 거품이 위로 올라가는 현상이라 이벤트 버블링(Event Bubbling)이라 부른다.

이벤트 버블링은 이벤트 객체의 `stopPropagation` 메소드로 전파를 막을 수 있다. 하지만 꼭 필요한 경우가 아니라면 버블링은 막아서는 안된다. 버블링은 등록 코드를 줄이는 유용한 현상이며, 아무 생각없이 버블링을 막으면 해당 영역은 ‘죽은 영역(dead zone)’이 되기 때문에 추후에 문제가 될 수도 있다.

💡 거의 모든 이벤트에는 버블링이 일어난다. 하지만 `focus` 와 같이 버블링 되지 않는 이벤트도 존재한다.

## 캡쳐링

캡처링은 버블링의 반대 방향으로 흐르는 전파라고 생각하면 된다.

한 요소에 이벤트가 발생되면 그의 자손 요소들의 이벤트도 같이 발생되는 현상이다. 브라우저의 기본 전파 방향은 자식에서 조상으로 올라가기 때문에 캡처링을 쓰려면 함수에 별도의 옵션을 넣어야 한다.

```c
target.addEventListener("click", function(){}, true);
```

`addEventListener()` 함수의 세 번째 매개변수로 true 값을 주면 해당 이벤트 타겟은 캡처링을 사용하게 된다.

## 위임

버블링과 캡쳐링을 활용하면 훨씬 효과적인 이벤트 핸들링 패턴인 이벤트 위임을 구현할 수 있다.

이벤트 위임은 비슷한 방식으로 여러 요소를 다뤄야 할 때 사용된다. 이는 요소마다 핸들러를 할당하지 않고, 공통 조상에 이벤트 핸들러를 단 하나만 할당하여 여러 요소를 한꺼번에 다루는 일이다. 공통 조상에 할당한 핸들러에서 `[event.target](http://event.target)` 을 이용하면 실제 어디서 이벤트가 발생 되었는지 알 수 있다.
