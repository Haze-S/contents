---
date: '2024-06-07'
title: 'Deep-Dive Book study session 1'
categories: ['Study']
tags: ['Book', 'React']
thumbnail: 'https://github.com/Haze-S/contents/assets/87344625/dc1b07e1-ee6b-495e-bfd9-82f03c993d69'
---

# 1.5 이벤트 루프와 비동기 통신의 이해

## 싱글 스레드 자바 스크립트

### 과거의 자바 스크립트

- 자바 스크립트의 역할
  - 웹 브라우저에서 HTML을 그릴 때 도움을 주는 보조적인 역할
  - 간단한 경고창이나 폼을 처리하는 기초적인 수준에서 제한적으로 사용됨
  - 따라서 자바 스크립트는 멀티 스레드 지원이 필요 없었음
  - 멀리 스레드를 지원하면 오히려 DOM 조작 시 타이밍 이슈가 발생할 가능성도 있다.

### 현재의 자바 스크립트

오늘 날 사용되는 자바 스크립트는 사용자의 행동에 따른 이벤트 관리와 데이터를 주고 받는 네트워킹 등 많은 일들 해야 한다. 이러한 일들을 싱글 스레드로 구현하게 된다면 웹 사이트는 데이터를 가져오는 동안 아무런 행동(이벤트)을 하지 않은 채로 멈춰있는 상태가 된다. 이는 사용자에게 웹 사이트가 제대로 동작하고 있는 지에 대한 신뢰를 떨어트리며 더불어 사용자 경험도 나빠진다.
웹의 발전에 따라 자바 스크립트 또한 발전이 필요했고, 자바 스크립트는 비동기 통신을 하게 된다.

```js
console.log(1);

setTimeout(() => {
  console.log(2);
}, 0);

setTimeout(() => {
  console.log(3);
}, 100);

console.log(4);
```

### 비동기 통신

비동기 통신이란 요청한 즉시 결과가 주어지지 않을 수 있고, 응답이 언제 올 지 모르는, 즉 동시에 일어나지 않는 것을 의미한다. 이는 동기식과 다르게 여러 작업을 동시에 수행할 수 있다는 장점이 있다.
위의 예시는 싱글 스레드인 자바 스크립트로 작동할 때 `1, 2, (0.1초 뒤) 3, 4` 로 출력되어야 하겠지만 `setTimeout()` 은 자바 스크립트의 대표적인 비동기 함수로서 해당 함수는 다른 코드들의 동작이 모두 끝난 후에 동작한다. 따라서 최종적인 출력 순서는 `1, 4, 2, 3` 이 된다.
싱글 스레드인 자바 스크립트에서 비동기 코드를 어떻게 처리할 수 있는 것일까?

## 이벤트 루프

자바 스크립트의 비동기 작동을 이해하려면 이벤트 루프의 개념을 알아야 한다. 이벤트 루프란 자바 스크립트의 내부가 아닌 외부에서 비동기 실행을 돕기 위해 만들어진 장치이다.

### 호출 스택과 이벤트 루프

호출 스택은 자바 스크립트에서 수행해야 할 코드나 함수를 순차적으로 담아두는 스택으로 이 스택이 비어 있는지 여부를 확인하는 것이 이벤트 루프이다. 만약 수행해야 할 코드가 있다면 자바스크립트 엔진을 이용해 실행한다. 코드를 실행하는 것과 호출 스택이 비어있는 지 확인하는 것 모두 단일 스레드에서 일어나기 때문에 두 작업은 동시에 일어날 수 없다.

```js
function bar() {
  console.log('bar');
}

function baz() {
  console.log('baz');
}

function foo() {
  console.log('foo');
  setTimeout(bar(), 0);
  baz();
}

foo();
```

위의 예제는 비동기 작업에 대한 코드다. 앞서 언급했듯이 `setTimeout()` 은 비동기 함수로 콘솔에 출력되는 순서는 `foo, baz, bar` 순으로 출력된다. 처음으로 `foo()` 함수가 호출된 후 `setTimeout()` 비동기 함수를 만나면 실제 호출 스택 내부에서는 타이머 이벤트가 실행, 태스크 큐로 들어간다. 그리고 호출 스택에 들어갔던 `setTimeout()` 함수는 바로 스택에서 제거된다. 그 뒤 코드가 차례대로 호출 스택에 넣어졌다 나왔다 하며 `foo()` 함수의 구현부가 모두 끝나면 호출 스택이 완전히 비워진다. 이때 이벤트 루프는 호출 스택과 태스크 큐를 확인하여 스택이 비워진 걸 확인한 후 태스크 큐에 있던 `bar()` 를 호출 스택에 넣어 실행한다.

### 태스크 큐

태스크 큐란 실행해야할 태스크의 집합을 의미하며 이벤트 루프는 태스크 큐를 한 개 이상 가지고 있다. 태스크 큐는 set 형태를 띠고 있는데 실행 가능한 큐 중에서 가장 오래된 태스크를 가져와야 하기 때문이다. 실행해야 할 태스크는 비동기 함수의 콜백 함수나 이벤트 핸들러 등을 의미한다.
즉, 이벤트 루프의 역할은 호출 스택에 실행중인 코드가 있는지, 태스크 큐에 대기 중인 함수가 있는지 반복해서 확인하는 역할을 한다. 그리고 이러한 비동기 작업들은 자바 스크립트의 메인 스레드가 아닌 태스크 큐가 할당되는 별도의 스레드에서 수행된다. 이 작업은 브라우저나 Node.js의 역할이다.

### 마이크로 태스크 큐

이벤트 루프는 하나의 마이크로 태스크 큐를 갖고 있는데, 기존 태스크 큐와는 다른 태스크를 처리한다. 대표적으로는 Promise가 있으며 기존 태스크 큐보다 우선권을 갖는다. 마이크로 태스크 큐가 빌 때까지는 기존 태스크 큐의 실행은 뒤로 미뤄진다. 추가로 렌더링은 마이크로 태스크 큐를 실행한 뒤에 일어나며 마이크로 태스크 큐 작업이 끝날 때마다 한 번씩 렌더링 기회를 얻는다. 따라서 동기 코드 외에 마이크로 태스크도 렌더링에 영향을 미치므로 어떤 식으로 분리해야 사용자 경험이 좋아질 지 고민하여 설계해야 한다.

# 1.6 리액트에서 자주 사용하는 자바스크립트 문법

## 구조 분해 할당

구조 분해 할당이란 배열 또는 객체의 값을 분해해 개별 변수에 즉시 할당하는 것을 의미한다.

### 배열 구조 분해 할당

리액트에서 배열 구조 분해 할당을 사용하는 대표적인 예는 useState이다.

```js
const array = [1, 2, 3, 4, 5];

const [first, second, third, ...arrayRest] = array;
```

할당을 생략하려면 `const [first, , , , fifth] = array` 와 같이 생략하면 되고 `const [a = 10, b = 10] = array` 같이 쓰면 기본값을 설정할 수도 있다. 기본값은 `null`에는 적용이 되지 않고 `undefined`일 때만 사용할 수 있다.

### 객체 구조 분해 할당

객체에서 값을 꺼내온 뒤 할당하는 것으로 객체 내부 이름으로 값을 꺼내온다.

```js
const object = {
  a: 1,
  b: 2,
  c: 3,
  d: 4,
  e: 5,
};

const { a, b, c, ...objectRest } = object;
```

`const {a: first, b: second} = object` 형식을 이용하여 새로운 이름으로 다시 할당하거나 기본 값을 주는 것도 가능하다. 이러한 방식은 리액트에서 props의 값을 바로 꺼낼 때 자주 쓰이는 방식이다. 변수에 있는 값으로 꺼내오는 "계산된 속성 이름 방식"도 가능하다.

```js
const key = 'a';
const object = {
  a: 1,
  b: 1,
};

const { [key]: a } = object;
```

계산된 속성 이름을 사용하려면 반드시 이름을 선언하는 변수 네이밍이 필요하다.
객체 구조 분해 할당의 경우 트랜스파일을 거치면 번들링 크기가 상대적으로 크기 때문에 꼭 써야 하는지 검토할 필요가 있다.

## 전개 구문

### 배열의 전개 구문

배열 내부에서 `...배열`을 사용하면 해당 배열을 전개하는 것 처럼 선언하고 기존 배열에 영향없이 배열을 복사하는 것도 가능하다.

```js
const arr1 = ['a', 'b'];
const arr2 = [...arr1, 'c', 'd', 'e']; // ['a', 'b', 'c', 'd', 'e']
```

### 객체의 전개 구문

객체 또한 배열과 비슷하게 사용이 가능하다. 다만 객체 전개 구문에 있어서 순서가 중요하다.

```js
const obj = {
  a: 1,
  b: 1,
  c: 1,
};

const aObj = {
  ...obj,
  c: 10,
}; //  {a: 1, b: 1, c: 10}

const bObj = {
  c: 10,
  ...obj,
}; //  {a: 1, b: 1, c: 1}
```

이전에 할당한 값은 다음에 할당되는 값으로 인해 덮어쓰이게 된다. 따라서 전개 구문이 어디에 적혀있냐에 따라 전혀 다른 객체가 생성될 수 있다.

## 객체 초기자

객체 초기자는 객체를 선언할 때 키와 값을 가지고 있는 변수가 이미 존재한다면 값을 간결하게 넣을 수 있는 방식이다.

```js
const a = 1;
const b = 2;

const obj = {
  a,
  b,
};
```

## Array 프로토타입의 메서드

배열과 관련된 메서드는 JSX 내부에서 배열을 조작해 원하는 JSX를 바로 반환할 수 있다. 기존 배열의 값을 건들지 않기 때문에 데이터가 변경될 염려없이 사용할 수 있다.

### map

인수로 전달 받은 배열과 똑같은 길이의 새로운 배열을 반환한다. 배열의 아이템을 순회하며 각 아이템을 콜백으로 연산한 결과로 배열을 구성한다. 리액트에서는 주로 특정 배열을 기반으로 요소를 반환하고자 할 때 많이 사용한다.

```jsx
const arr = [1, 2, 3, 4, 5];
const Elements = arr.map((item) => {
  return <Fragment key={item}>{item}</Fragment>;
});
```

### filter

콜백 함수에서 truthy 조건을 만족하는 경우에만 해당 원소를 반환한다. 필터링 역할을 하는 메서드로 결과에 따라 원본 배열 길이 이하의 새로운 배열이 반환된다. 주로 어떠한 조건을 만족하는 새로운 배열을 반환할 때 쓰인다.

```jsx
const arr = [1, 2, 3, 4, 5];
const evenArr = arr.filter((item) => item % 2 === 0);
```

### reduce

콜백함수와 초깃값을 인수로 받아서 초깃값에 따라 배열이나 객체, 혹은 다른 무언가를 반환한다. 콜백 함수를 실행하여 초깃값에 누적해 결과를 반환한다. 배열을 원하는 하나의 객체로 변환하는 등 다양한 상황에서 사용된다.

```jsx
const arr = [1, 2, 3, 4, 5];
const sum = arr.reduce((acc, cur) => {
  return acc + cur;
}, 0);
```

### forEach

배열을 순회하며 단순히 콜백 함수를 실행한다. forEach의 경우 아무런 반환값이 없기 때문에 사용에 주의해야 하며 `forEach` 가 실행되는 순간 프로세스를 종료하거나 에러를 던지지 않는다면 `break`, `return` 으로는 배열 순회를 멈출 수 없다. `forEach` 에서 쓰이는 `return` 은 해당 메서드가 아닌 콜백 함수의 `return` 으로 간주된다.

## 삼항 조건 연산자

유일하게 3개의 피연산자를 취하며 조건에 따라 반환되는 값을 달리 줄 때 사용된다. JSX 내부에서 조건부로 렌더링하기 위해 가장 흔히 쓰이는 방법이다. 중첩해서 사용할 수 있지만 가독성을 위해 가능한 중첩하지 않는 것이 좋다.

```jsx
function component({ condition }) {
  return <>{condition ? '참' : '거짓'}</>;
}
```

# 1.7 선택이 아닌 필수, 타입스크립트

## 타입스크립트란?

> "TypeScript is JavaScript with syntax for types"
> _타입 스크립트 홈페이지 발췌_

기존 자바 스크립트 문법에 타입을 가미한 것이 타입 스크립트이다. 자바 스크립트는 동적 타입 언어이기 때문에 런타임 시에만 에러를 확인할 수 있는데, 이는 작성된 코드가 에러의 위험에 노출되어 있는 것이다. 타입 스크립트는 타입 체크를 런타임 전인 빌드 타임에 수행하게 한다. 이는 변수에 타입을 지정하여 오직 지정한 타입만 할당할 수 있게 제한을 둠으로서 코드를 확인할 수 있게 되는 것이다. 정리하자면 타입 스크립트는 자바 스크립트의 슈퍼셋으로서 함수의 반환 타입, enum, 배열 등 타입 관련 작업을 할 수 있게 하고 interface, extends 를 이용하여 객체 지향적으로 코드를 쓸 수 있게 해준다.

단, 어디까지나 자바 스크립트의 슈퍼셋으로 자바 스크립트가 불가능 한 일은 타입 스크립트도 하지 못 한다. 타입 스크립트로 작성된 파일은 자바 스크립트로 컴파일 되어 Node나 브라우저 환경에서 실행된다.

## 타입 스크립트 활용법

### any 대신 unknown을 사용하자

`any` 는 모든 타입을 지칭하는 것으로 사실상 타입 스크립트를 쓰는 이유가 사라진다. 불가피하게 타입을 단정할 수 없는 경우에는 `unknown` 을 사용하는 것이 좋다. `unknown` 또한 모든 값을 할당할 수 있는 top type으로 어떤 값이든 할당할 수 있다. 하지만 `any` 와 다르게 바로 사용하는 것을 불가능하다. `unknown` 으로 선언된 변수를 사용하기 위해서는 type narrowing, 타입을 의도한대로 적절히 좁혀야 한다.

```ts
function doSomething(callback: unknown) {
  if (typeof callback === 'function') {
    callback();
    return;
  }

  throw new Error('callback은 함수여야 합니다.');
}
```

top type과 반대되는 bottom type으로 `never` 가 있다. 이는 어떠한 타입도 들어올 수 없음을 의미하며 코드상으로 존재가 불가능한 타입을 나타낼 때 사용된다. 타입 스크립트로 클래스 컴포넌트를 선언할 때 props는 없지만 state가 존재하는 상황에서 어떠한 props도 받지 않는다는 뜻으로 사용이 가능하다.

### 타입 가드를 활용하자

타입을 사용하는 쪽에서는 최대한 타입을 좁히는 것이 좋으며 이때 도움을 주는 것이 타입 가드이다. 조건문과 함께 사용하면 효과적으로 좁혀 조금 더 명확하게 변수나 함수를 사용할 수 있다.

- `instanceof` 와 `typeof`

`instanceof` 는 지정한 인스턴스가 특정 클래스의 인스턴스인지 확인할 수 있는 연산자이다. `unknown` 으로 내려오는 에러에 대해 타입 가드를 걸어 타입을 좁힘으로 에러에 따라 원하는 처리 내용을 추가할 수 있다.
`typeof` 는 특정 요소에 대해 자료형을 확인하는 데 사용된다.

- `in`

`in` 은 `property in object` 로 사용되는데 주로 객체에 키가 존재하는지 확인하는 용도로 사용된다. `in` 을 활용해 특정 객체에만 있는 프로퍼티 값을 확인하고 조건문으로 좁히는 방식을 사용한다.

```ts
interface Student {
  age: number;
  score: number;
}

interface Teacher {
  name: string;
}

function doSchool(person: Student | Teacher) {
  if ('age' in person) {
    person.age;
    person.score;
  }

  if ('name' in person) {
    person.name;
  }
}
```

조건문으로 두 객체에 겹치지 않는 프로퍼티를 확인하여 해당 변수가 어떤 타입에서 내려오는지 체크할 수 있다. `in` 은 타입에 여러 가지 객체가 존재할 수 있는 경우 유용하다.

### 제네릭

제네릭은 함수나 클래스 내부에서 다양한 타입에 대응할 수 있도록 도와준다. 제네릭을 사용할 경우 타입만 다른 비슷한 작업을 하는 컴포넌트를 단일 제네릭 컴포넌트로 선언해 간결하게 작성할 수 있다.

```ts
function getFirstAndLast<T>(list: T[]): [T, T] {
  return [list[0], list[list.length - 1]];
}

const [first, last] = getFirstAndLast([1, 2, 3, 4, 5]);

first; // number
last; // number

const [first, last] = getFirstAndLast(['a', 'b', 'c', 'd', 'e']);

first; // string
last; //string
```

`T` 라는 제네릭을 선언해 각각 배열의 요소와 반환 값의 요소로 사용, 제네릭 덕분에 해당 함수는 다양한 타입을 처리할 수 있는 함수가 되었다. 리액트에서는 대표적인 예로 useState가 있다. useState를 사용할 때 초기값을 넘기지 않으면 값을 `undefined` 로 추론되는데 useState의 제네릭에 기본 타입을 선언해준다면 이런 문제를 타입 스크립트가 방지해 줄 수 있다. 제네릭은 하나 이상 사용할 수도 있다.

### 인덱스 시그니처

객체의 키를 정의하는 방식을 의미한다. 인덱스 시그니처를 사용하면 키에 원하는 타입을 부여할 수 있다.

```ts
type Hello = {
  [key: string]: string;
};

const hello: Hello = {
  hello: 'hello',
  hi: 'hi',
};

hello['hi']; // hi
hello['안녕']; // undefined
```

동적인 객체를 정의하는 경우엔 유용하지만 그렇지 않은 경우 존재하지 않는 키로 접근하면 `undefined`를 반환한다. 따라서 객체의 키는 동적으로 선언되는 경우를 최대한 줄이고 필요에 따라 객체의 타입도 좁혀야 한다. 추가로 `Record<Key, Value>` 형태도 객체의 타입에 각각 원하는 키와 값을 넣을 수 있다.

인덱스 시그니처를 사용했을 때 `Object.keys` 를 사용하면 `string[]` 타입으로 반환한다. 이 string은 객체의 인덱스 키로 접근할 수 없기 때문에 `No index` 이슈가 발생하게 된다. 이는

- as로 타입을 단언
- 타입 가드 함수
- 가져온 키를 단언

하는 방법으로 해결할 수 있다.

### 덕 타이핑

자바 스크립트는 객체가 열려있는 구조로 만들어져 덕 타이핑으로 객체를 비교하는 특징이 있다. 덕 타이핑이란 객체의 생김새(형태)가 같다면(키와 값의 타입이 같다면) 같은 타입으로 인정하는 것이다. 즉, 모든 키가 들어올 수 있는 가능성이 열려 있는 객체의 키에 포괄적으로 대응하기 위해 `Object.keys` 는 `string[]` 으로 타입을 제공한다.

## 타입 스크립트 전환 가이드

자바 스크립트 프로젝트를 타입 스크립트로 전환하게 된다면 필요할 가이드이다.

### tsconfig.json 먼저 작성하기

최상위 디렉터리에 `tsconfig.json` 파일을 생성, [공식 문서](https://www.typescriptlang.org/ko/docs/handbook/tsconfig-json.html)를 보면서 타입 스크립트를 작성할 수 있는 환경을 만든다.

### JSDoc 과 @ts-check를 활용하여 점진적으로 전환

파일을 타입 스크립트로 전환하지 않고 먼저 파일 최상단에 `//@ts-check` 를 선언하고 JSDoc을 활용해 타입을 제공하면 타입 스크립트 컴파일러가 파일의 타입을 확인한다. 이는 꽤나 손이 가는 작업으로 만약 기존 프로젝트에 JSDoc을 이미 사용했거나 타입 스크립트로 전환하기 어려울 때만 이 방법을 사용하는 것을 추천하며, 그 외에는 바로 `.ts` 로 파일 확장자를 변경하고 작업하는 편이 더 빠르다.

### @types 모듈 설치

타입 스크립트로 작성되지 않은 코드에 대한 타입을 제공하는 라이브러리이다. 리액트에서 사용할 때도 해당 모듈을 설치해야 한다.

### 파일 단위로 조금씩 전환

별도의 의존성을 가지고 있지 않은 파일을 시작으로 점진적으로 전환한다. `js-to-ts-converter` 와 같이 타입 스크립트로 전환해 주는 도구가 있지만 급한 게 아니라면 추천하지 않는다.
