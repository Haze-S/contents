---
date: '2024-06-18'
title: 'Deep-Dive Book study session 3'
categories: ['Study']
tags: ['Book', 'React']
thumbnail: 'https://github.com/Haze-S/contents/assets/87344625/dc1b07e1-ee6b-495e-bfd9-82f03c993d69'
---

# 11장 Next.js 13과 리액트 18

Next.js 버전 13은 서버 사이드 렌더링의 구조에 변화가 많은 리액트 18을 채택, 레이아웃 지원을 본격적으로 지원하기 시작했다. 웹팩을 대체할 Turbopack까지 출시했다.

## 11.1 app 디렉터리의 등장

페이지 별로 공통 레이아웃이 존재한다 가정했을 때, 리액트에서는 react-router-dom을 사용하여 `<Routes>` 외부 영역 같이 해당 주소의 또 다른 영역을 공통으로 꾸미는 작업 등이 가능했다. Next의 경우 13 버전 이전에는 모든 페이지가 물리적으로 구별된 파일로 독립되어 있었으며 페이지 공통으로 사용되는 것을 설정하는 건 `_document` 와 `_app` 이 유일했다. 더군다나 `_document` 파일은 서버에서만 동작하므로 클라이언트 로직을 붙이는 게 불가능했고 이는 공통 레이아웃을 유지하는 방법이 `_app` 밖에 없었음을 의미한다. 이는 각 페이지별로 다른 레이아웃을 유지할 수 있는 여지가 부족했다. 이를 개선하기 위해 나온 것이 app 레이아웃이다.

### 11.1.1 라우팅

기존에 `/pages` 로 정의하던 라우팅 방식이 `/app` 디렉터리로 이동했고 더이상 파일명으로 라우팅하는 것은 불가능해졌다.

#### 라우팅을 정의하는 법

기본적으로 파일 시스템을 기반으로 하고 있으며 `/app` 디렉터리 내부의 디렉터리 명이 곧 url의 path가 된다. 하지만 이전과 달리 파일명은 라우팅 명칭에 아무런 영향을 미치지 못 한다.

#### layout.js

app 디렉터리 내부에 포함될 수 있는 파일명은 몇 가지로 제한되어 있다. `layout` 이라는 파일명은 페이지의 기본적인 레이아웃을 구성하는 요소이다. 해당 폴더에 layout이 있다면 그 하위 폴더 및 주소에 모두 영향을 미친다. 루트에는 단 하나의 layout을 만들 수 있으며 이는 모든 페이지에 영향을 미치는 공통 레이아웃이다. 꼭 공통 레이아웃이 필요하지 않더라도 웹페이지에 필요한 기본 정보만 담아도 좋다. 이전에 쓰이던 `_app` 과 `_document` 를 대신하는 파일로 생각하면 될 것 같다. 하지만 이전과 다르게 주소별로 나눌 수도 있으며 모든 페이지가 아닌 자신과 자식 라우팅에만 영향을 끼치게 구조를 짤 수도 있다.

##### 사용할 때 규칙

- `layout` 은 예약어로서 사용되며 레이아웃 이외의 다른 목적으로 사용할 수 없다.
- children 을 props 로 받아서 렌더링해야 한다.
- 내부에는 반드시 `export default` 로 내보내는 컴포넌트가 있어야 한다.
- 내부에서 API 요청과 같은 비동기 작업을 수행할 수 있다.

#### page.js

`page` 도 예약어이며 일반적으로 다뤘던 페이지를 의미한다. page는 layout을 기반으로 리액트 컴포넌트를 노출하게 되며 받게되는 props 는 아래와 같다.

- params
  - 옵셔널 값, 동적 라우트 파라미터를 사용할 경우 해당 파라미터에 값이 들어온다.
- searchParams
  - url의 쿼리 스트링을 의미한다. 자바스크립트 객체 형태로 키와 값이 함께 오며 해당 값은 layout에서는 제공되지 않는다. layout의 경우 페이지 탐색 중에는 리렌더링을 하지 않기 때문이다. 따라서 search parameter에 의존적인 작업을 할 경우 반드시 page 내부에서 수행해야 한다.

##### 사용할 때 규칙

- `page` 는 예약어로 사용되며 레이아웃 이외에 다른 목적으로 사용할 수 없다.
- 내부에 `export default` 로 내보내는 컴포넌트가 있어야 한다.

#### error.js

라우팅 영역에서 사용되는 공통 에러 컴포넌트로 라우팅 별 다른 에러 UI를 렌더링 하는 것이 가능하다. 에러 바운더리는 클라이언트에서만 작동하므로 error 컴포넌트도 클라이언트 컴포넌트여야 한다. 또한 같은 수준의 layout에서 에러가 발생할 경우 해당 error 컴포넌트로 이동하지 않는다. 만약 layout에서 발생한 에러를 처리하고 싶다면 상위 컴포넌트의 error 를 사용하거나 루트 에러 처리를 담당하는 `app/global-error` 페이지를 생성하면 된다.

#### not-found.js

특정 라우팅의 하위 주소를 찾을 수 없는 404 페이지를 렌더링할 때 사용된다. 전체 앱에서 404를 노출하려면 `app/not-pound` 파일을 생성하면 되고 해당 컴포넌트는 서버 컴포넌트로 구성하면 된다.

#### loading.js

리액트 Suspense를 기반으로 해당 컴포넌트가 로딩 중임을 나타낼 때 사용할 수 있다. 이 컴포넌트를 `"use client"` 지시자를 사용하여 클라이언트 렌더링도 가능하다.

#### route.js

`/app/api` 를 기준으로 디렌터리 라우팅을 지원하며 파일명 라우팅은 없어졌다. 디렉터리가 라우팅 주소를 담당하며 파일명은 `route` 로 통일하게 됐다. 해당 파일 내부에는 REST API의 메서드명을 예약어로 선언해두면 HTTP 요쳥에 맞게 해당 메서드를 호출할 수 있다. `/app/api` 외에 다른 곳에서 선언해도 작동하지만 `route` 파일이 존재하는 폴더 내부에는 `page` 파일이 존재할 수 없다. `route` 의 함수들이 받을 수 있는 파라미터는 아래와 같다.

- request
  - NextRequest 객체이며 fetch 의 Request 를 확장한 Next 만의 Request 라 보면 된다. 해당 객체에는 cookie, headers, nextUrl 등을 확인할 수 있다.
- context
  - params만 가지고 있는 객체로 동적 라우팅 파라미터 객체가 포함된다.

## 11.2 리액트 서버 컴포넌트

### 11.2.1 기존 리액트 컴포넌트와 서버 사이드 렌더링의 한계

리액트의 모든 컴포넌트는 클라이언트에서 작동하며 브라우저에서 자바스크립트 코드 처리가 이뤄진다. 웹사이트를 방문하면 리액트 실행에 필요한 코드를 다운로드하고 리액트 컴포넌트 트리를 만든 다음 DOM에 렌더링한다. 서버 사이드 렌더링의 경우엔 미리 서버에서 DOM을 만들어 온 뒤 클라이언트에서는 해당 DOM을 기준으로 하이드레이션을 진행한다. 이러한 방식에는 아래와 같은 한계점이 있다.

- 자바스크립트 번들 크기가 0인 컴포넌트를 만들 수 없다.
- 백엔드 리소스에 대한 직접적인 접근이 불가능하다.
- 코드를 나누어 동적으로 지연 로딩함으로 초기화 속도를 높여주는 기법인 자동 코드 분할이 불가능하다.
- 연쇄적으로 발생하는 클라이언트와 서버의 요청을 대응하기 어렵다.
- 추상화에 드는 비용이 증가한다.

위의 한계점은 리액트가 클라이언트 중심으로 돌아가기 때문에 발생하는 문제이다. 그렇다고 과거의 정적인 방식의 서버 사이드 렌더링을 도입한다면 고객에게 다양한 경험을 주기는 힘들다.

### 11.2.2 서버 컴포넌트란?

서버 컴포넌트란 하나의 언어, 하나의 프레임워크, 그리고 하나의 API와 개념을 사용하면서 서버와 클라이언트 모두에서 컴포넌트를 렌더링할 수 있는 기법을 의미한다. 일부 컴포넌트는 클라이언트에서, 일부 컴포넌트는 서버에서 렌더링된다. 클라이언트 컴포넌트는 서버 컴포넌트를 import 할 수 없다. 왜냐하면 서버 환경은 브라우저에 존재하지 않기 때문에 클라이언트 컴포넌트에서 서버 컴포넌트를 실행할 방법이 없다.

![CC-SC tree](https://github.com/Haze-S/contents/assets/87344625/97538cbf-d75a-4650-a01f-226b8589bf08)

children으로 자주 사용되는 ReactNode에 의해 모든 컴포넌트는 서버 컴포넌트 혹은 클라이언트 컴포넌트가 될 수 있다.

##### 서버 컴포넌트

- 요청이 오는 순간 서버에서 딱 한 번 실행되므로 상태를 가질 수 없다. 따라서 상태를 가지는 `useState`, `useReducer` 등의 훅을 사용할 수 없다.
- 렌더링은 한 번만 일어나기 때문에 `useEffect`, `useLayoutEffect` 등 렌더링 생명 주기를 사용할 수 없다.
- 위의 두 가지 제약사항으로 인해 effect 나 state 에 의존하는 사용자 정의 훅을 사용할 수 없다.
- 서버에서만 실행되기 때문에 DOM API를 쓰거나 window.document 등에 접근할 수 없다.
- DB, 파일 시스템 등 서버에만 있는 데이터를 async/await으로 접근할 수 있다.
- 다른 서버 컴포넌트, HTML 요소, 클라이언트 컴포넌트를 렌더링할 수 있다.

##### 클라이언트 컴포넌트

- 브라우저 환경에서만 실행되므로 서버 컴포넌트나 서버 전용 훅, 유틸리티 등을 불러올 수 없다.
- 서버 컴포넌트가 클라이언트 컴포넌트를 렌더링 할 때, 해당 클라이언트 컴포넌트의 자식으로 서버 컴포넌트를 가질 순 있다.
- 위 두 가지 예외 사항을 제외하면 일반적인 리액트 컴포넌트와 같다.

##### 공용 컴포넌트

- 서버와 클라이언트 모두 사용할 수 있으며 두 컴포넌트의 모든 제약을 받는 컴포넌트가 된다.

리액트는 모든 것을 다 공용 컴포넌트로 판단하며, 파일 맨 첫 줄에 `"use client"` 를 명시하면 해당 컴포넌트는 클라이언트 컴포넌트로 쓸 수 있다.

### 11.2.3 서버 사이드 렌더링과 서버 컴포넌트의 차이

서버 사이드 렌더링은 응답받은 페이지 전체를 HTML로 렌더링하는 과정을 서버에서 수행한 후 그 결과를 클라이언트에 내려준다. 초기에 인터렉션은 불가능하지만 정적인 HTML을 빠르게 내려주는 데 초점을 둔다. 하지만 HTML이 로딩된 이후에는 자바스크립트 코드를 다운로드하고 파싱하고 실행하는 비용이 여전히 따라온다.

따라서 이후에는 서버 사이드 렌더링과 서버 컴포넌트를 모두 채택하는 것도 가능해질 것이며 두 가지 방법을 모두 결합하면 클라이언트 및 서버 컴포넌트를 모두 빠르게 보여줄 수 있고, 동시에 클라이언트에서 내려받아야 하는 자바스크립트의 양도 줄어들어 브라우저의 부담을 덜 수도 있다.

### 11.2.4 서버 컴포넌트는 어떻게 작동하는가?

1. 서버가 렌더링 요청을 받으면 서버 컴포넌트를 사용하는 모든 페이지는 항상 서버에서 시작된다. 즉, 루트 컴포넌트는 항상 서버 컴포넌트이다.
2. 서버는 받은 요청에 따라 컴포넌트를 JSON으로 직렬화한다. 서버에서 렌더링할 수 있는 것은 직렬화해서 내보내고 클라이언트 컴포넌트로 표시된 부분은 플레이스홀더 형식으로 비워두고 나타낸다. 브라우저는 이후에 해당 결과물을 받아서 다시 역직렬화한 다음 렌더링을 수행한다.
3. 브라우저가 컴포넌트 트리를 구성하고 렌더링해 브라우저의 DOM에 커밋한다.

##### 서버 컴포넌트 작동 방식의 특징

- 서버에서 클라이언트로 정보를 보낼 때 스트리밍 형태로 보내어 JSON을 줄 단위로 읽고 컴포넌트를 렌더링할 수 있다. 따라서 사용자에게 결과물을 빨리 보여줄 수 있다.
- 각 컴포넌트별로 번들링이 별개로 돼 있어 필요에 따라 지연해서 받거나 따로 받는 등의 작업이 가능하다.
- SSR과 다르게 결과물이 HTML이 아닌 JSON 형태로 보내져 HTML을 그리는 작업 이상의 일을 필요로 한다. 따라서 리액트 컴포넌트 트리의 구성을 최대한 빠르게 할 수 있다.
- 위와 같은 특징으로 인해 **서버 컴포넌트에서 클라이언트 컴포넌트로 props를 넘길 땐 반드시 직렬화 가능한 데이터를 넘겨야 한다**

## 11.3 Next.js에서의 리액트 서버 컴포넌트

Next 13버전부터 서버 컴포넌트를 도입했고 `/app` 디렉터리에 구현 돼 있다.
기본적인 서버 컴포넌트의 제약은 동일하며 Next의 루트 컴포넌트는 각 페이지에 존재하는 `page`, `layout` 파일이다. 즉, `page` 와 `layout` 파일은 반드시 서버 컴포넌트여야 하며 서버 컴포넌트의 제약을 받는다.

### 11.3.1 새로운 fetch 도입과 getServerSideProps, getStaticProps, getInitialProps의 삭제

버전 13 이전에 SSR과 SSG를 위해 사용된 함수들은 `/app` 디렉터리 내부에서 삭제됐으며, 모든 데이터 요청은 웹에서 제공하는 표준 API인 fetch를 기반으로 이뤄진다.

```jsx
async function getData() {
  // 데이터를 불러온다.
  const result = await fetch('https://api.example.com/');

  if (!result.ok) {
    // 에러를 던지면 가장 가까운 에러 바운더리에 전달된다.
    throw new Error('실패');
  }

  return result.json();
}

// async 서버 컴포넌트 페이지
export default async function Page() {
  const data = await getData();

  return (
    <main>
      <Children data={data} />
    </main>
  );
}
```

같은 서버 컴포넌트 트리 내에서 동일한 요청이 있다면 재요청이 발생하지 않도록 요청 중복을 방지했다. fetch 요청에 대한 내용을 서버에서는 렌더링이 한 번 끝날 때까지 캐싱하며, 클라이언트에서는 별도의 지시자나 요청이 없는 이상 해당 데이터를 최대한 캐싱해서 중복된 요청을 방지한다.

### 11.3.2 정적 렌더링과 동적 렌더링

이전에는 `getStaticProps` 를 활용해 SSG 렌더링이 가능했다. 이 기능을 활용하면 해당 주소로 들어올 때 모든 결과물이 동일하기 때문에 CDN에서 캐싱해 기존 SSR보다 더 빠르게 데이터를 제공할 수 있었다.

Next 13 이후로 정적 라우팅에 대해선 기본적으로 빌드 타임에 렌더링을 미리 하고 캐싱해 재사용 할 수 있게 설정되었고, 동적 라우팅은 요청이 올 때마다 렌더링하도록 변경됐다.

반면 `{ cache: 'no-cache' }` 옵션을 추가해 캐싱하지 않겠다는 설정도 할 수 있다. 해당 옵션을 사용하게 되면 요청이 올 때 fetch 요청 이후에 렌더링을 수행한다.

이 밖에도 함수 내부에서 헤더 정보와 쿠키 정보를 불러오는 함수를 사용하게 되면 동적인 연산을 바탕으로 결과를 반환하는 것으로 인식해 정적 렌더링 대상에서 제외된다.

동적인 주소이지만 특정 주소에 대해 캐싱하고 싶은 경우, `generateStaticParams`를 사용하면 된다.

### 11.3.3 캐시와 mutating, 그리고 revalidating

Next에서는 fetch의 기본 작동을 재정의할 수 있어서 이를 바탕으로 해당 데이터의 유효시간을 정해두고 시간이 지나면 다시 데이터를 불러와 렌더링하는 것이 가능하다. 캐시와 갱신이 이뤄지는 과정은 아래와 같다.

1. 최초 요청 시 미리 캐시한 정적 데이터를 보여준다.
2. 해당 요청은 revalidate에 선언된 값만큼 유지된다.
3. 해당 시간이 지나도 일단 캐시된 데이터를 보여준다.
4. Next에서는 캐시된 데이터를 보여주는 한편, 백그라운드에서는 다시 데이터를 불러온다.
5. 4번 작업이 성공적으로 끝나면 캐시된 데이터를 갱신하고, 그렇지 않으면 과거 데이터를 보여준다.

캐시를 전체적으로 무효화하고 싶다면 `router.refresh();` 를 사용하면 된다. 이는 브라우저의 히스토리나 리액트의 state에는 영향을 미치지 않고 데이터를 전체적으로 가져와서 갱신하게 된다.

### 11.3.4 스트리밍을 활용한 점진적인 페이지 불러오기

![스트리밍 안 쓴 이미지](https://github.com/Haze-S/contents/assets/87344625/50e459b9-c8f7-4b3c-8fc5-f45cdcfd2aba)

SSR의 경우 요청받은 페이지를 서버에서 모두 렌더링해서 보내기 전까지 유저는 빈 페이지를 보게 된다. 그리고 페이지를 다 받아도 하이드레이션 과정을 거쳐야 유저가 사용할 수 있는 페이지가 된다.

![스트리밍 쓴 이미지](https://github.com/Haze-S/contents/assets/87344625/7170722b-aab0-4723-b23e-55e409f007e2)

이를 해결하기 위해 HTML을 작은 단위로 쪼개 완성되는 대로 클라이언트로 보내는 스트리밍이 도입됐다. 이는 유저가 일부라도 페이지와 인터랙션할 수 있다는 것을 의미하며 TTFB와 FCP를 개선하는 데 큰 도움을 준다.

##### 경로에 loading.tsx 배치

`loading` 은 예약어로 존재하는 컴포넌트로 렌더링이 완료되기 전에 보여줄 수 있는 컴포넌트를 배치할 수 있다. 해당 파일을 배치하면 자동으로 Suspense가 배치된다.

##### Suspense 배치

좀 더 세분화된 제어를 하고 싶다면 직접 리액트의 Suspense를 배치하는 것도 가능하다.

```jsx
export default function Posts() {
  return (
    <section>
      <Suspense fallback={<Skeleton />}>
        <Notes />
      </Suspense>
      <Suspense fallback={<Skeleton />}>
        <Peoples />
      </Suspense>
    </section>
  );
}
```

두 가지 방법 다 동일한 혜택을 누릴 수 있다.

## 11.4 웹팩의 대항마, 터보팩의 등장(beta)

Next 13에서는 웹팩의 후계자를 자처하는 터보팩이 출시됐다. 이는 웹팩 대비 최대 700배, Vite 대비 최대 10배 빠르다고 하며, 이는 러스트 기반으로 작성됐기 때문에 가능하다고 소개되고 있다.

다만 아직 베타버전으로 개발 모드에서만 제한적으로 사용 가능하다. 따라서 `next dev --turbo` 명령어를 통해 활성화하여 개발할 수 있다.
