---
date: '2024-04-07'
title: 'Virtual DOM'
categories: ['Note']
tags: ['React', 'WIL']
thumbnail: 'https://github.com/Haze-S/blog-contents/assets/87344625/c4b6f98d-0a52-43e6-a82b-56b26889d453'
---

![virtual1](https://github.com/Haze-S/blog-contents/assets/87344625/c4b6f98d-0a52-43e6-a82b-56b26889d453)

가상돔(Virtual DOM)은 실제 DOM(Document Object Model)의 가벼운 복제품이다. 웹 페이지는 DOM이 업데이트 될 때마다 Render Tree를 재생성하고 reflow와 repaint 과정을 거치게 된다. 기존 웹은 DOM의 변경이 별로 없었지만 SPA가 등장하여 DOM의 업데이트가 잦아졌다.
이 복제품은 실제 DOM에 접근하여 조작하는 대신 이를 추상화하여 자바스크립트 객체를 구성하여 사용한다.

## Virtual DOM 쓰는 이유

- **UI 표현의 추상화**
  - 웹 애플리케이션의 UI 표현을 추상화한다.
  - 즉, 실제 DOM의 구조와 상태를 가볍게 복제하여 메모리에 유지한다.
- **상태 변경 추적**
  - 사용자 상호작용이나 데이터 변경과 같은 이벤트가 발생하면, 리액트는 가상돔을 사용하여 변경 사항을 추적한다.
  - 이를 통해 어떤 부분이 업데이트되어야 하는지를 결정할 수 있다.
- **가상돔 비교**
  - 상태 변경이 감지되면, 리액트는 이전 가상돔과 현재 가상돔을 비교한다.
  - 변경된 부분을 식별하고 실제 DOM에 적용할 변경 사항을 결정한다.
  - 이는 메모리 상에서 동작하며 실제 렌더링이 발생하지 않아 연산 비용이 적다.
- **최적화된 돔 조작**
  - 변경 사항이 식별되면, 리액트는 최소한의 돔 조작만 수행하여 실제 DOM을 업데이트 한다.
  - 이를 통해 불필요한 돔 조작을 줄이고 성능을 향상시킨다.
- **리랜더링 최적화**
  - 리액트는 컴포넌트의 상태나 속성이 변경될 때마다 전체 UI를 리랜더링하는 대신, 가상돔을 사용하여 변경된 부분만 업데이트 한다.
  - DOM이 변경될 때 마다 렌더링하지 않고 n번의 변경들을 모아뒀다가 하나로 묶어 딱 한번 실행한다.
- **크로스 플랫폼 호환성**
  - 다양한 플랫폼과 환경에서 일관된 사용자 경험을 제공하도록 도움을 준다.
- **개발 생산성 향상**
  - 리액트의 컴포넌트 기반 아키텍처와 잘 통합되어 개발 생산성을 높일 수 있다.

## Virtual DOM 안 쓰는 이유

- **초기 렌더링 오버헤드**
  - 가상돔은 초기 렌더링 시에 실제 돔과의 동기화를 위한 추가적인 오버헤드가 발생할 수 있다.
  - 이는 초기 페이지 로드 시에 사용자 경험을 약간 저하시킬 수 있다.
- **메모리 사용량 증가**
  - 가상돔은 메모리에 별도로 유지되어야 하므로, 대규모 애플리케이션에서는 메모리 사용량이 증가할 수 있다.
  - 특히 복잡한 UI나 대용량 데이터를 다루는 경우에는 이러한 문제가 더 두드러질 수 있다.
- **복잡한 UI 업데이트 처리**
  - 개발자가 애플리케이션의 뷰(View)와 상태(State)를 동기화하기 위해 추가적인 추상화 계층을 사용해야 한다.
  - 이로 인해 애플리케이션의 복잡성이 증가할 수 있다.
- **SEO 문제**
  - 리액트 애플리케이션은 기본적으로 서버 측 렌더링을 지원하지 않는다.
  - 따라서 검색 엔진 최적화 (SEO)를 위해 추가적인 설정이 필요할 수 있다.
  - 서버 사이드 렌더링을 구현하거나, 프리렌더링 등의 방법을 사용하여 SEO 문제를 해결할 수 있지만, 이는 추가적인 복잡성을 야기할 수 있다.
- **과도한 추상화**
  - 일부 개발자들은 리액트의 추상화된 접근 방식이 너무 많은 작업을 추상화하고 숨기는 것으로 느낄 수 있다.
  - 이로 인해 개발자들은 어떤 일이 일어나고 있는지 이해하기 어려울 수 있다.
- **돔의 변화가 거의 없는 경우**
  - 가상돔은 모든 상황에서 적합한 매커니즘이 아니다.
  - 변화가 거의 없는 정적인 사이트나 작은 규모의 앱에서는 불필요한 오버헤드가 발생한다.

이러한 장단점을 고려하여 리액트의 가상돔을 사용할지 여부를 결정할 수 있다. 일반적으로 리액트는 대부분의 경우에 성능과 생산성 측면에서 매우 우수하지만, 특정한 상황에 따라 다른 라이브러리나 프레임워크를 고려할 필요가 있다.

### Virtual DOM 언제 쓰지?

위에서 언급했듯이 개발자는 프로젝트의 성격과 상황을 고려하여 기술 스택을 선택할 필요가 있다.

#### 대규모 데이터 및 복잡한 UI

대규모 데이터를 처리하거나 복잡한 UI를 가진 웹 애플리케이션을 개발할 때, 가상돔은 변경 사항을 효율적으로 추적하고 업데이트하는 데 도움이 되므로, 성능을 향상시키는 데 유용하다.

#### 실시간 데이터 업데이트

실시간 데이터를 업데이트하는 웹 애플리케이션을 개발할 때, 변경 사항을 실시간으로 추적하고 업데이트하는 데 특히 유용하며, UI를 빠르게 반응시키는 데 도움이 된다.

#### 다양한 환경 호환성

다양한 브라우저 및 디바이스에서 일관된 UI를 제공해야 하는 경우, 가상돔은 크로스 플랫폼 호환성을 향상시키는 데 도움이 되며, 다양한 환경에서 일관된 사용자 경험을 제공한다.

#### 복잡한 상태 관리

복잡한 상태 관리가 필요한 웹 애플리케이션을 개발할 때, 가상돔은 상태 변경을 추적하고 업데이트하는 데 도움이 되며, 상태 관리를 보다 효율적으로 처리할 수 있게 해준다.

### 그럼 언제 안 쓰지?

#### 단순한 정적인 UI

단순한 정적인 UI를 가진 웹 애플리케이션의 경우, 가상돔을 사용하는 것은 비효율적일 수 있다. 가상돔은 상태 변화를 추적하고 업데이트하는 데 사용되므로, 정적인 UI의 경우에는 추가적인 오버헤드만 발생할 수 있다.

#### 렌더링 속도가 중요하지 않은 경우

웹 애플리케이션의 렌더링 속도가 큰 문제가 되지 않는 경우, 가상돔을 사용할 필요가 없을 수 있다. 가상돔은 상태 변화를 효율적으로 처리하고 성능을 향상시키는 데 사용되지만, 렌더링 속도가 중요하지 않은 경우에는 다른 방식을 고려할 수 있다.

#### 초기 렌더링 오버헤드

가상돔은 초기 렌더링에 추가적인 오버헤드를 발생시킬 수 있다. 초기에는 실제 돔과 가상돔을 동기화해야 하므로 약간의 성능 저하가 발생할 수 있다. 따라서 초기 렌더링 오버헤드가 중요한 경우에는 가상돔을 사용하지 않는 것이 더 나을 수 있다.

#### 기존 코드와의 호환성 문제

기존에 가상돔을 사용하지 않는 코드와의 호환성 문제가 발생할 수 있다. 일부 라이브러리나 프레임워크는 가상돔을 사용하지 않기 때문에, 기존 코드와의 호환성 문제가 발생할 수 있다.

이러한 경우에는 가상돔을 사용하지 않는 것이 더 적합할 수 있다. 개발자는 프로젝트의 요구 사항과 상황에 맞게 가상돔을 적절히 활용하거나 선택해야 한다.

### 그렇다면 리액트는 쓰지만 가상돔은 안 쓸 수도 있지 않을까?

리액트를 사용하는데 가상돔을 사용하지 않는 방법도 있다. 일부 경우에는 가상돔을 사용하지 않고 직접적으로 실제 DOM을 조작하는 것이 더 적합할 수 있다. 이를 위해 리액트에서는 다음과 같은 방법을 제공한다.

1. **ReactDOM.render() 사용**
   ReactDOM.render() 함수를 사용하여 리액트 컴포넌트를 직접적으로 실제 DOM에 렌더링할 수 있다. 이 경우에는 가상돔을 사용하지 않고도 리액트 컴포넌트를 렌더링할 수 있다. 이 방법은 단일한 컴포넌트를 렌더링하는 간단한 애플리케이션에 적합하다.
2. **React.createElement() 사용**
   React.createElement() 함수를 사용하여 리액트 요소를 직접적으로 생성하고 실제 DOM에 추가할 수 있다. 이 방법은 JSX를 사용하지 않는 경우에 유용하며, 가상돔을 거치지 않고 직접적으로 DOM 요소를 생성할 수 있다.

이러한 방법들을 사용하여 가상돔을 사용하지 않고도 리액트를 사용할 수 있지만 리액트의 주요 장점 중 하나인 가상돔을 활용하지 못하게 되므로, 성능 및 개발 생산성에 영향을 줄 수 있다. 따라서 가상돔을 사용하지 않는 경우에는 성능 및 개발 편의성을 고려하여 적절한 대안을 선택해야 한다.

### 주의할 점

**리액트는 노드를 비교할 때 얕은 비교를 한다.**
배열이나 객체 등 참조값을 이용하는 자료형은 그 안의 값을 비교하지 않고 참조되는 위치를 비교한다. 따라서 원본 배열을 직접 수정하는 방식으로 state를 다시 세팅해도 실제 값이 변화되었지 참조값은 변경되지 않았기 때문에 이를 감지할 수 없다.

따라서 참조형을 두고 state 변경을 원한다면 원본을 수정하지 않고 깊은 복사를 한 후 사용해야 한다. 깊은 복사를 하는 방법은 스프레드 연산자를 사용하면 편리하다.
