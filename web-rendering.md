---
date: "2024-04-18"
title: "[Web] 웹 페이지 렌더링 방식"
categories: ["Web", "WIL"]
summary: "렌더링은 브라우저에 화면을 전달하는 과정이다."
thumbnail: "https://github.com/Haze-S/blog-contents/assets/87344625/6481ebae-9b14-445b-a5ec-5a44c953c362"
---

<p align=center>
  <img src="https://github.com/Haze-S/blog-contents/assets/87344625/6481ebae-9b14-445b-a5ec-5a44c953c362">
</p>

웹 페이지 렌더링은 사용자가 웹 브라우저를 통해 웹 페이지를 열었을 때, 브라우저가 HTML, CSS, JavaScript 등의 리소스를 받아와 사용자가 볼 수 있는 화면을 생성하는 과정을 의미한다. 렌더링 방식에 따라 로딩 속도, 검색 엔진 최적화(SEO), 사용자 경험(UX) 등이 달라진다.

### 렌더링 과정

1. **서버 요청**
   사용자가 웹 페이지의 URL을 입력하거나 링크를 클릭하면, 브라우저는 해당 URL에 해당하는 웹 페이지를 요청한다. 이 요청은 HTTP 프로토콜을 사용하여 서버에 전송된다.
2. **HTML 다운로드**
   서버는 요청을 받으면, 요청에 따른 HTML 문서를 생성하여 브라우저에 응답한다. 브라우저는 이 HTML 문서를 다운로드한다.
3. **DOM 생성**
   브라우저는 다운로드한 HTML 문서를 파싱하여 DOM(Document Object Model)을 생성한다. DOM은 문서의 구조화된 표현으로, HTML 요소와 요소 간의 관계를 나타내는 트리 구조이다.
4. **CSS 다운로드 및 스타일 계산**
   브라우저는 HTML을 파싱하는 동안 CSS(Cascading Style Sheets) 파일을 다운로드하고, 스타일 규칙을 계산하여 각 요소에 적용한다. 이를 통해 각 요소의 크기, 위치, 색상 등이 결정된다.
5. **렌더 트리 생성**
   DOM과 CSSOM(CSS Object Model)을 결합하여 렌더 트리(Render Tree)를 생성한다. 이는 화면에 표시되는 요소들의 계층 구조를 나타내는 트리로 각 요소의 스타일 및 레이아웃 정보를 포함한다.
6. **레이아웃 및 페인팅**
   브라우저는 렌더 트리를 기반으로 요소의 레이아웃을 계산하고, 화면에 실제로 그려질 픽셀을 결정한다. 이 과정을 레이아웃(Layout) 및 페인팅(Paint)이라고 한다.
7. **화면에 표시**
   레이아웃 및 페인팅이 완료되면 브라우저는 사용자가 볼 수 있는 화면을 생성하여 표시한다. 이때 화면에 표시되는 내용은 렌더 트리에 따라 결정된다.

웹 페이지 렌더링 과정은 사용자의 브라우저에서 이루어지며, 웹 페이지의 구조와 스타일에 따라 렌더링 속도와 성능이 달라질 수 있다. 최적의 사용자 경험을 제공하기 위해 웹 페이지의 렌더링 속도를 최적화하는 것이 중요하다.

## CSR (Client-Side Rendering)

![ren1](https://github.com/Haze-S/blog-contents/assets/87344625/4a801c03-fe37-4158-8445-826ed7ff0187)

- 웹 애플리케이션에서 사용자의 브라우저에서 동적으로 페이지를 생성하는 방식
- 서버에서는 초기 HTML과 빈 페이지를 전달하고, 클라이언트는 JavaScript를 사용하여 페이지를 렌더링하고 데이터를 가져와서 보여준다.
- 맨 처음 비어있는 HTML을 받기 때문에 초기 로딩 속도는 느리지만 이후에는 추가 페이지 요청 대신 데이터만 서버에서 받아 해당 부분만 업데이트하기 때문에 빠르다.
- 대표적으로 React, Vue.js 등의 프레임워크에서 CSR을 사용한다.

### 장점

- 초기 로딩 후에는 클라이언트에서 동적으로 페이지를 업데이트할 수 있어 사용자 경험이 향상된다.
- 사용자와 상호작용이 많은 웹 애플리케이션에 적합하다.
- 서버의 부담이 적어진다.

### 단점

- 초기 로딩 시에는 빈 페이지가 먼저 보이고, JavaScript 및 데이터 다운로드가 완료되어야 페이지가 완전히 렌더링된다.
- 검색 엔진 최적화(SEO)가 어렵다.
- 브라우저에서 JavaScript를 지원하지 않는 경우 사용할 수 없다.

## SSR (Server-Side Rendering)

![ren2](https://github.com/Haze-S/blog-contents/assets/87344625/36f85f7b-cb4e-4ef7-96c7-f2ba2e625316)

- 웹 서버에서 페이지를 렌더링 마치고 완성된 HTML을 사용자에게 제공하는 방식
- 사용자가 페이지를 요청할 때마다 서버에서 요청에 대한 HTML을 생성하고 전송하므로 서버 부하가 커질 수 있다.
- React, Vue.js 등의 클라이언트 사이드 렌더링 프레임워크를 서버 사이드에서 실행하여 사용할 수 있다.

### 장점

- 초기 로딩 시에 완성된 HTML을 바로 제공하여 사용자가 빠르게 콘텐츠를 볼 수 있다.
- 검색 엔진 최적화(SEO)에 유리하다.
- 브라우저에서 JavaScript를 지원하지 않는 경우에도 작동한다.

### 단점

- 서버에 부하가 많이 걸릴 수 있다.
- 클라이언트 사이드 라우팅과 상호작용이 많은 경우에는 추가적인 구현이 필요할 수 있다.

## SSG (Static Site Generation)

![ren3](https://github.com/Haze-S/blog-contents/assets/87344625/b5d4696e-098a-4d2b-a2ee-b04979fb7f46)

- 빌드 시간에 모든 페이지를 미리 렌더링하여 정적 파일로 생성하는 방식
- 사용자가 페이지를 요청할 때마다 서버에서 새로운 HTML을 생성하는 것이 아니라, 미리 생성된 정적 파일을 제공한다.
- 초기 로딩 속도가 매우 빠르고 서버 부하가 적으며, CDN(Content Delivery Network)을 사용하여 전 세계에서 빠르게 캐싱될 수 있다.
- 대표적으로 Next.js, Gatsby 등의 프레임워크에서 SSG을 사용한다.

### 장점

- 초기 로딩 속도가 매우 빠르다.
- 서버 부담이 적고, CDN을 통해 캐싱되어 전 세계에서 빠르게 서비스될 수 있다.
- 보안에 더욱 강력하다.

### 단점

- 동적 데이터에 대한 처리가 어려울 수 있다.
  - 하지만, 클라이언트 사이드에서 동적으로 데이터를 가져와서 처리하는 방식을 사용할 수 있다.
- 사용자와의 상호작용이 적은 정적인 사이트에 적합하다.
- 페이지가 빌드될 때마다 갱신되어야 하므로, 실시간 업데이트가 필요한 경우에는 적합하지 않을 수 있다.

## ISR(Incremental Static Regeneration)

![ren4](https://github.com/Haze-S/blog-contents/assets/87344625/ef3277a0-7553-41cb-9781-630a42e2ee05)

- SSG와 SSR의 단점은 보완하고 장점은 결합한, Next.js 프레임워크에서 도입된 렌더링 방식.
- 빌드 시점에 미리 페이지를 생성하면서 특정 시간 간격으로 페이지를 재생성하여 업데이트 된 데이터를 반영한다.
- 빌드 시점에 Next.js에서는 `getStaticProps`와 `revalidate` 옵션을 이용하여 페이지를 어떻게 생성하고, 언제 생성할지를 설정할 수 있다.
- 새로운 사용자의 요청이 들어왔을 때, `revalidate` 옵션의 설정된 시간이 경과되면 해당 페이지를 서버에서 재생성한다.
- 새로운 요청이 있을 때에만 페이지가 재생성되며, 재생성 중에는 이전의 페이지가 계속해서 보이게 된다.

### 장점

- 페이지가 미리 생성되어 있으므로 즉시 응답, 로딩 속도가 빠르다.
- 정해진 시간 간격으로 새로운 요청이 들어오면 페이지를 재생성하기 때문에 데이터의 변경을 실시간으로 반영할 수 있다.
- 모든 요청에 대해 실시간으로 페이지를 생성하지 않으므로, 서버 부하를 줄일 수 있다.

### 단점

- 각 페이지의 상태를 관리해야 하므로 구현이 비교적 복잡하다.
- 페이지의 재생성에는 시간이 소요되므로, 매우 빈번하게 변경되는 데이터는 반영하기 어렵다.

## 각 방식을 언제 사용하면 될까?

각각의 렌더링 방식은 다른 상황에서 적합하므로, 프로젝트의 요구 사항과 목표에 따라 선택해야 한다.

#### 1. CSR (Client-Side Rendering)

- 사용자와의 상호작용이 많은 웹 애플리케이션, SPA(Single Page Application)에 적합
- 초기 로딩 속도보다 사용자 경험과 동적인 UI가 중요한 경우에 적합
- 서버 부하를 최소화하고 클라이언트에서의 로직 처리를 선호하는 경우에 적합

#### 2. SSR (Server-Side Rendering)

- 초기 로딩 속도가 중요하고 검색 엔진 최적화(SEO)가 필요한 경우
- 사용자와의 상호작용이 적고, 페이지가 동적으로 변하지 않는 경우에 적합

#### 3. SSG (Static Site Generation)

- 초기 로딩 속도가 매우 중요하고, 콘텐츠가 자주 변경되지 않는 경우
- 보안과 성능이 우선되는 정적인 웹 사이트, 블로그, 문서 사이트 등에 적합

#### 4. ISR(Incremental Static Regeneration)

- 일부 페이지는 자주 업데이트되고, 다른 일부 페이지는 그렇지 않은 경우

이러한 상황에 맞추어 적절한 렌더링 방식을 선택하여 프로젝트를 구현하는 것이 중요하다. 종종 프로젝트의 요구 사항은 여러 가지 방식의 조합이 될 수도 있다.

---

[이미지 출처](https://velog.io/@haizel/Web-RenderingClient-Server#-%EC%A0%81%ED%95%A9%ED%95%9C-%EC%83%81%ED%99%A9-1)
